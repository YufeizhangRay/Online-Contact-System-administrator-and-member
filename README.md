# Online-Contact-System(administrator-and-member)
线上成员通讯录系统
  
学习`Java`以来的第二个项目，第一次运用了`Java`的`Socket`编程，`多线程`以及`JDBC`(这也是第一次通过代码操作数据库)。同时项目分为`Server`与`Client`两个部分，并且第一次使用了`Serializable关键字`进行对象的传输，在一定程度上为之后学习理解`RMI`原理以及手写自己的简易`RPC`框架打下了一个小小的基础。  
  
如何创建一个线程：  
>实现线程的方式一共有三种：继承`Thread`类、实现`Runnable`接口、使用`ExecutorService`、`Callable`、`Future`实现带返回结果的多线程(有的时候，我们可能需要让一步执行的线程在执行完成以后，提供一个`返回值`给到当前的`主线程`，主线程需要依赖这个值进行后续的`逻辑处理`，那么这个时候，就需要用到带返回值的线程了)。因为没有继承别的类的需求，本项目采用了直接继承`Thread`类的实现方法(若需要继承别的类，则无法使用此方法，而是要选择实现`Runnable`接口或者`Callable`接口，因为`Java`只能支持`单继承多实现`，而不能多继承)。继承`Thread`类或者实现`Runnable`接口之后，我们都需要重写(`@Override`)`run()`方法(`Thread`类实质上就是实现了`Runnable`接口的特殊类，其他类可以通过继承`Thread`类获得多线程的特性，因为继承属于`is-a`的关系)，但是要注意的是，我们在启动线程的时候不能直接调用`run()`方法，而是要采用`start()`方法。如果世界调用`run()`方法线程不会真正的启动，而是由主线程(调用线程)直接执行其内部逻辑。  
  
多线程可能存在的问题及解决办法：  
>多线程的使用可能会导致数据不一致问题，也就是我们所说的`线程安全`问题。例如当两个线程同时对`同一个共享变量`进行`写操作`(同时都是读操作不存在线程问题)的时候，会因为线程互相之间`不可见`而导致数据的丢失。  
从计算机的角度上来讲：  
>>由于计算机的存储设备与处理器的`运算速度差距非常大`，所以现代计算机系统都会增加一层读写速度尽可能接近处理器运算速度的高速缓存来作为内存和处理器之间的缓冲：将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步到内存之中。多`CPU`的情况下，每一个`CPU`都会拥有自己的高速缓存，而且`CPU`之间是无法看到对方缓存中的数据的。`CPU-0`读取主存的数据，缓存到`CPU-0`的高速缓存中，`CPU-1`也做了同样的事情，而`CPU-1`把`count`的值修改成了 `2`，并且同步到`CPU-1`的高速缓存，但是这个修改以后的值并没有写入到主存中，`CPU-0`访问该字节，由于缓存没有更新，所以仍然是之前的值，就会导致数据不一致的问题。  
解决这个问题可以使用`总线锁`或者`缓存锁`以及`缓存一致性协议(MESI)`。
  
>从Java的角度来讲：
>>线程是`CPU调度的最小单元`，`JMM`(`Java Memory Model`，`Java内存模型`)使每一个线程都拥有自己的工作缓存，这样的情况与多核`CPU`的情况非常相似，导致线程之间存在可见性的问题。例如两个线程同时对共享变量`a(初始a=1)`进行`a=a+1`操作，两个线程读到的值都是`1`，操作完之后的值都是`2`，写回到主存中的值也是`2`，而不是`3`。  
解决可见性问题，可以使用`volatile关键字`。使用这个关键字的变量，在进行操作的时候`JVM`会在其`字节码`之前加上`lock前缀`，只要是加入这个前缀的指令，都会使线程工作缓存的数据`立即`写回主存，在写回主存之前，由于`缓存一致性协议`，其他线程的工作缓存中对应数据会被标记为`无效`(`Invalid`)，这样下次这些线程就会直接去主存中获取最新的数据，从而保证了`可见性`的问题。同时`volatile关键字`还会加上`内存屏障`，保证了`有序性`。但是`volatile关键`字并`不能`保证`原子性`，若多个线程进行`i++`操作，最后的结果永远都是`小于等于`我们的预期值(因为操作结果被覆盖)。因为在`字节码`层面上`i++`操作并`不是单一`的操作，而是分为`读操作`，`加操作`，`写操作`。只有写操作的指令上才有`lock前缀`，也就是说写之前的操作都是不可见的。若一个线程在另一个线程发出写指令之前读到了就已经从自己的`工作缓存`中拿到了数据，那么它就会直接对这个数据进行操作。若想解决`原子性`问题，我们可以用`volatile`和`CAS`(`Compare And Swap`)的经典组合来实现，其本质就是一种`乐观锁`的实现，在`AQS`(`AbstractQueuedSynchronizer`)中有大量的应用。`ReentrantLock`(`可重入锁`)、`ReentrantReadWriteLock`（`读写锁`）、`CountDownLatch`、`Semaphore`都是基于`AQS`实现的，由于篇幅原因，这里不祥讲。  
也有一种更简单的方法来保证`原子性`，那就是直接使用`synchronized关键字`。`synchronized关键字`在`字节码`层面上会发出`monitorenter`与`monitorexit`指令，去获得与释放对象的`Monitor`，相当获取与释放锁，是`悲观锁`的一种体现。保证了线程的执行先后，也就保证了`可见性`，`有序性`与`原子性`。`synchronized关键字`与`volatile`和`CAS`的组合相比，效率上可能会低一点，但是具体也要看实际情况。如果碰撞非常多，不建议使用`CAS`，因为每次碰撞都会导致`自旋`，自旋的时候什么都不做，浪费`CPU`。

操作`JDBC`，需要注意的是`ResultSet`(`结果集`)每次返回的时候指向的位置是`第一条数据之前`，而不是第一条数据本身。`JDBC`在实际开发中应用的应该是非常少了，现在很多优秀的`ORM`框架(`Hibernate`、`Mybatis`等)都可以使开发者用更轻松的方式操作数据库。但是需要了解的是，这些框架的实现原理其实都是在`底层封装`了`JDBC`(包括`Spring`的`事务回滚`)，实际上还是`JDBC`在进行操作。
